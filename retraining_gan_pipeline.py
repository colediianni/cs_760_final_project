# -*- coding: utf-8 -*-
"""retraining_GAN_pipeline.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1coANGHW5b-r-TVih_p9gqCyXSdja-sO2

# Importing
"""

import numpy
from numpy import expand_dims
from numpy import zeros
from numpy import ones
from numpy.random import randn
from numpy.random import randint
from keras.datasets.fashion_mnist import load_data
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Reshape
from keras.layers import Flatten
from keras.layers import Conv2D
from keras.layers import Conv2DTranspose
from keras.layers import LeakyReLU
from keras.layers import Dropout
from tensorflow.keras.layers import MaxPooling2D
from tensorflow.keras.optimizers import SGD
import tensorflow as tf
import random
from tensorflow.keras.models import load_model

# Setting Seed
numpy.random.seed(seed=123)
random.seed(123)

def generate_latent_points(latent_dim, n_samples):
	# generate points in the latent space
	x_input = randn(latent_dim * n_samples)
	# reshape into a batch of inputs for the network
	x_input = x_input.reshape(n_samples, latent_dim)
	return x_input

"""# Connecting Models (in order) Updating GAN Weights"""

GAN_model = load_model('/content/drive/MyDrive/ML_760/Final_Proj/generator.h5')
target_model = load_model('/content/drive/MyDrive/ML_760/Final_Proj/GAN_discriminator_architecture_model.h5')
attack_model = load_model('PATH')

model = Sequential()
model.add(GAN_model)
model.add(target_model)
model.add(attack_model)
model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])

model.summary()

# Freeze layers (other than GAN)
model.layers[1].trainable = False
model.layers[2].trainable = False

# Training
epochs = 10:
for i in range(epochs):
  # generate images
  x = generate_latent_points(100, 100)
  y = ones((n_samples, 1))
  model.train_on_batch(X, Y)
model.save('/content/drive/MyDrive/ML_760/Final_Proj/basic_membership_attack_model.h5')

"""# GD On Noise Vector"""

GAN_model = load_model('/content/drive/MyDrive/ML_760/Final_Proj/generator.h5')
target_model = load_model('/content/drive/MyDrive/ML_760/Final_Proj/GAN_discriminator_architecture_model.h5')
attack_model = load_model('PATH')

model = Sequential()
model.add(GAN_model)
model.add(target_model)
model.add(attack_model)
model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])

model.summary()

# Freeze layers (other than GAN)
model.layers[1].trainable = False
model.layers[2].trainable = False

# Training
epochs = 10:
for i in range(epochs):
  # generate images
  x = generate_latent_points(100, 100)
  y = ones((n_samples, 1))
  model.train_on_batch(X, Y)
model.save('/content/drive/MyDrive/ML_760/Final_Proj/basic_membership_attack_model.h5')

"""# Connecting Models (GAN discriminator branch)"""

import numpy
from numpy import expand_dims
from numpy import zeros
from numpy import ones
from numpy.random import randn
from numpy.random import randint
from keras.datasets.fashion_mnist import load_data
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Reshape
from keras.layers import Flatten
from keras.layers import Conv2D
from keras.layers import Conv2DTranspose
from keras.layers import LeakyReLU
from keras.layers import Dropout
import tensorflow as tf
# Setting Seed
numpy.random.seed(seed=123)
 
# define the standalone discriminator model
def define_discriminator(in_shape=(28,28,1)):
	model = Sequential()
	# downsample
	model.add(Conv2D(128, (3,3), strides=(2,2), padding='same', input_shape=in_shape))
	model.add(LeakyReLU(alpha=0.2))
	# downsample
	model.add(Conv2D(128, (3,3), strides=(2,2), padding='same'))
	model.add(LeakyReLU(alpha=0.2))
	# classifier
	model.add(Flatten())
	model.add(Dropout(0.4))
	model.add(Dense(1, activation='sigmoid'))
	# compile model
	opt = tf.keras.optimizers.Adam(learning_rate=0.0002, beta_1=0.5)
	model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])
	return model
 
# define the standalone generator model
def define_generator(latent_dim):
	model = Sequential()
	# foundation for 7x7 image
	n_nodes = 128 * 7 * 7
	model.add(Dense(n_nodes, input_dim=latent_dim))
	model.add(LeakyReLU(alpha=0.2))
	model.add(Reshape((7, 7, 128)))
	# upsample to 14x14
	model.add(Conv2DTranspose(128, (4,4), strides=(2,2), padding='same'))
	model.add(LeakyReLU(alpha=0.2))
	# upsample to 28x28
	model.add(Conv2DTranspose(128, (4,4), strides=(2,2), padding='same'))
	model.add(LeakyReLU(alpha=0.2))
	# generate
	model.add(Conv2D(1, (7,7), activation='tanh', padding='same'))
	return model
 
# define the combined generator and discriminator model, for updating the generator
def define_gan(generator, discriminator):
	# make weights in the discriminator not trainable
	discriminator.trainable = False
	# connect them
	model = Sequential()
	# add generator
	model.add(generator)
	# add the discriminator
	model.add(discriminator)
	# compile model
	opt = tf.keras.optimizers.Adam(learning_rate=0.0002, beta_1=0.5)
	model.compile(loss='binary_crossentropy', optimizer=opt)
	return model

def define_membership_constructor(generator, target_model, attack_model):
  # Freeze layers (other than generator)
  target_model.trainable = False
  attack_model.trainable = False

  model = Sequential()
  model.add(generator)
  model.add(target_model)
  model.add(attack_model)
  opt = tf.keras.optimizers.Adam(learning_rate=0.0002, beta_1=0.5)
  model.compile(loss='binary_crossentropy', optimizer=opt, metrics=['accuracy'])
  return model

 
# load fashion mnist images
def load_real_samples():
	# load dataset
	(trainX, _), (_, _) = load_data()
	trainX = trainX[:int(len(trainX)/2)] # Taking first half of data for GAN training
	# expand to 3d, e.g. add channels
	X = expand_dims(trainX, axis=-1)
	# convert from ints to floats
	X = X.astype('float32')
	# scale from [0,255] to [-1,1]
	X = (X - 127.5) / 127.5
	return X
 
# select real samples
def generate_real_samples(dataset, n_samples):
	# choose random instances
	ix = randint(0, dataset.shape[0], n_samples)
	# select images
	X = dataset[ix]
	# generate class labels
	y = ones((n_samples, 1))
	return X, y
 
# generate points in latent space as input for the generator
def generate_latent_points(latent_dim, n_samples):
	# generate points in the latent space
	x_input = randn(latent_dim * n_samples)
	# reshape into a batch of inputs for the network
	x_input = x_input.reshape(n_samples, latent_dim)
	return x_input
 
# use the generator to generate n fake examples, with class labels
def generate_fake_samples(generator, latent_dim, n_samples):
	# generate points in latent space
	x_input = generate_latent_points(latent_dim, n_samples)
	# predict outputs
	X = generator.predict(x_input)
	# create class labels
	y = zeros((n_samples, 1))
	return X, y
 
# train the generator and discriminator
def train(g_model, d_model, gan_model, membership_construction_branch_model, dataset, latent_dim, n_epochs=100, n_batch=128):
	bat_per_epo = int(dataset.shape[0] / n_batch)
	half_batch = int(n_batch / 2)
	# manually enumerate epochs
	for i in range(n_epochs):
		# enumerate batches over the training set
		for j in range(bat_per_epo):
			# get randomly selected 'real' samples
			X_real, y_real = generate_real_samples(dataset, half_batch)
			# update discriminator model weights
			d_loss1, _ = d_model.train_on_batch(X_real, y_real)
			# generate 'fake' examples
			X_fake, y_fake = generate_fake_samples(g_model, latent_dim, half_batch)
			# update discriminator model weights
			d_loss2, _ = d_model.train_on_batch(X_fake, y_fake)
			# prepare points in latent space as input for the generator
			X_gan = generate_latent_points(latent_dim, n_batch)
			# create inverted labels for the fake samples
			y_gan = ones((n_batch, 1))
			# update the generator via the discriminator's error
			g_loss = gan_model.train_on_batch(X_gan, y_gan)

      X_gan = generate_latent_points(latent_dim, n_batch)
			# create inverted labels for the fake samples
			y_gan = ones((n_batch, 1))
			# update the generator via the discriminator's error
			mi_loss = membership_construction_branch_model.train_on_batch(X_gan, y_gan)

			# summarize loss on this batch
		print('>%d, d1=%.3f, d2=%.3f g=%.3f, mi=%.3f' %
			(i+1, d_loss1, d_loss2, g_loss, mi_loss))
	# save the generator model
	g_model.save('/content/drive/MyDrive/ML_760/Final_Proj/branched_membership_attack_model.h5')
	return g_model
 
# size of the latent space
latent_dim = 100
# create the discriminator
discriminator = define_discriminator()
# create the generator
generator = define_generator(latent_dim)
# create the gan
gan_branch_model = define_gan(generator, discriminator)

# load target and attack models
target_model = load_model('/content/drive/MyDrive/ML_760/Final_Proj/GAN_discriminator_architecture_model.h5')
attack_model = load_model('PATH')

# create the membership construction branch
membership_construction_branch_model = define_membership_constructor(generator, target_model, attack_model)

from keras.utils.vis_utils import plot_model
plot_model(membership_construction_branch_model, show_shapes=True, show_layer_names=True)

# load image data
dataset = load_real_samples()
# train model
gen_model = train(generator, discriminator, gan_branch_model, membership_construction_branch_model, dataset, latent_dim)